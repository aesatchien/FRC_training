"""
Simple g-code generator for an arrays of user-generated point   2022 0210 CJH
Useful for both the shapeoko and the benchmill

User generates  a pointlist [ [], [], ... ] however they want and calls
generate_gcode() to get the gcode and
plot_points() to get a plot of the points

"""

import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime

# options - defaults, can be overridden by user


# machine parameters
settings_dict = {
    'shapeoko':{'DRILL_DEPTH':-0.12, 'RETRACT_HEIGHT':0.5, 'ENGAGE_HEIGHT':0.1,
                'LINEAR_FEED':100, 'DRILL_FEED':5, 'RETRACT_FEED':30, 'MILL_STEP':0.04, 'PART_DEPTH':0.40,
                'TOOL_DIAMETER':0.25, 'CUT_FEED':20, 'MILL_CIRCLES':False, 'HOLE_DIAMETER': 0.201-0.125} ,
    'benchmill':{'DRILL_DEPTH':-0.2, 'RETRACT_HEIGHT':0.5, 'ENGAGE_HEIGHT':0.1,
                'LINEAR_FEED':30, 'DRILL_FEED':3, 'RETRACT_FEED':20, 'TOOL':4, 'PECK_TOOL':5,
                'PECK_STEP':0.05, 'MILL_CIRCLES':False, 'HOLE_DIAMETER': 0.201-0.125},
}


def tool_travel(point_list):
    travel = 0
    for ix, point in enumerate(point_list[:-1]):  # must be a one liner for this in numpy or scipy
        travel += ((point[0]-point_list[ix+1][0])**2 + (point[1]-point_list[ix+1][1])**2)**0.5
    return travel


def distance(point_1, point_2):
    return ((point_1[0]-point_2[0])**2 + (point_1[1]-point_2[1])**2)**0.5

def sort_list(point_list):
    # sort for machine travel time - simple way, see if it is faster to sort on x or y
    #x_sort = sorted(point_list)  # sort on x values
    #y_sort = sorted(point_list, key=lambda x:x[1])  # sort on y values
    #sorted_list = x_sort if tool_travel(x_sort) < tool_travel(y_sort) else y_sort

    # shortest walk, starting with the first point
    dummy_list = point_list.copy()
    shortest_walk = [dummy_list.pop(0)]
    steps = len(dummy_list)
    for i in range(steps):
        # sorting on a tuple - distance and then choose consistently (should be x below) if it's a tie on distance
        dummy_list = sorted(dummy_list, key=lambda p: (distance(p, shortest_walk[-1]), p[0]))
        shortest_walk.append(dummy_list.pop(0))
    sorted_list = shortest_walk.copy()
    return sorted_list


def generate_gcode(point_list, machine='shapeoko', overrides=None, peck=False, save_file=False, file_description='test', time_stamp=True):
    # set the intro and outro G code
    intro_code, outro_code = None, None

    action = 'circles' if settings_dict[machine]['MILL_CIRCLES'] else 'center_drill'

    if overrides is not None:
        # allow user to pass in a dictionary to update the machine settings
        settings_dict[machine].update(overrides)
        print(f'Using the following settings: {settings_dict[machine]}\n')

    sorted_list = sort_list(point_list)

    if machine == 'shapeoko':
        intro_code = f'; ## {action.upper()} CODE AUTOGENERATED FROM POINT LIST FOR SHAPEOKO- CJH {datetime.today().strftime("%Y %m%d %H:%M:%S")}'
        intro_code += f'\nN1 G90 G20 G00 Z1. M00\n; N2 (1/8 EM CRB 2FL 1/2 LOC)\nN3 S12000 M03\nG01 Z{settings_dict[machine]["RETRACT_HEIGHT"]} F{settings_dict[machine]["RETRACT_FEED"]}\n'
        outro_code = '; ## END OF POINTS\nN1520 G91 G28 Z0\nN1521 G28 X0 Y0\n; ## END OF AUTOGENERATED PROGRAM'
        # just individual plunges - that's all the shapeoko can do
        message = intro_code
        for ix, point in enumerate(sorted_list):
            # move to x,y, drill, retract
            message = message + f'; ## POINT #{ix}:\n'
            message = message + f'G01 X{point[0]} Y{point[1]} F{settings_dict[machine]["LINEAR_FEED"]}\n'
            message = message + f'G01 Z{settings_dict[machine]["ENGAGE_HEIGHT"]} F{settings_dict[machine]["RETRACT_FEED"]}\n'
            message = message + f'Z{settings_dict[machine]["DRILL_DEPTH"]} F{settings_dict[machine]["DRILL_FEED"]}\n'
            if settings_dict[machine]['MILL_CIRCLES']:
                message = message + f'G01 X{point[0]} Y{point[1] + settings_dict[machine]["HOLE_DIAMETER"] / 2:.4f} F{settings_dict[machine]["CUT_FEED"]} ; TOP OF CIRCLE\n'
                relative = True  # GRBL / default forces I and J to be relative?
                radius = settings_dict[machine]["HOLE_DIAMETER"] / 2
                for _ in range(2):
                    if relative:  # I guess GRBL wants these things relative?  Also, R is suposed to override I and J, but not sure - this makes it work on both mill and router
                        # four points on the circle because some interpreters are dumb / some half circles are ambiguous,
                        message = message + f'G03 X{point[0] - radius } Y{point[1]:.4f} I{radius} J{0:.4f} R{radius} F{settings_dict[machine]["CUT_FEED"]} ; ARC CCW LEFT OF CIRCLE\n'
                        message = message + f'G03 X{point[0]} Y{point[1] - radius :.4f} I{0} J{-radius:.4f} R{radius} F{settings_dict[machine]["CUT_FEED"]} ; ARC CCW BOTTOM OF CIRCLE\n'
                        message = message + f'G03 X{point[0] + radius} Y{point[1]:.4f} I{-radius} J{0:.4f} R{radius} F{settings_dict[machine]["CUT_FEED"]} ; ARC CCW RIGHT OF CIRCLE\n'
                        message = message + f'G03 X{point[0]} Y{point[1] + radius:.4f} I{0} J{radius:.4f} R{radius} F{settings_dict[machine]["CUT_FEED"]} ; ARC CCW TOP OF CIRCLE\n'
                    else:  # mill is fine with absolute
                        message = message + f'G03 X{point[0]} Y{point[1] - settings_dict[machine]["HOLE_DIAMETER"] / 2:.4f} I{point[0]} J{point[1]} F{settings_dict[machine]["CUT_FEED"]} ; ARC CCW BOTTOM OF CIRCLE\n'
                        message = message + f'G03 X{point[0]} Y{point[1] + settings_dict[machine]["HOLE_DIAMETER"]/2:.4f} I{point[0]} J{point[1]} F{settings_dict[machine]["CUT_FEED"]} ; ARC CCW TOP OF CIRCLE\n'
                message = message + f'G01 X{point[0]} Y{point[1]} F{settings_dict[machine]["DRILL_FEED"]} ; RETURN TO CENTER\n'
            message = message + f"Z{settings_dict[machine]['RETRACT_HEIGHT']} F{settings_dict[machine]['RETRACT_FEED']}\n"
        command = message + outro_code

    elif machine == 'benchmill':
        intro_code = f'; ## DRILL CODE AUTOGENERATED FROM POINT LIST FOR BENCHMILL- CJH {datetime.today().strftime("%Y %m%d %H:%M:%S")}'
        intro_code += f'\nN0002 G17 G20 G40 G80\nN0004 G00 G53 G90 Z0\nN0006 (3/8 X 90DEG CBT SPOT DRILL)\nN0008 T0{settings_dict[machine]["PECK_TOOL"] if peck else settings_dict[machine]["TOOL"]} M06'
        intro_code += f'\nN0010 S3000 M03\nG01 Z{settings_dict[machine]["RETRACT_HEIGHT"]} F{settings_dict[machine]["RETRACT_FEED"]}\n'
        outro_code = 'nN0046 G91 Z1 (CJH RAISE TOOL)\nN0048 M30\n; ## END OF AUTOGENERATED PROGRAM'
        message = intro_code
        message = message + f'N0030 G00 G90 X{sorted_list[0][0]} Y{sorted_list[0][1]}\n'
        message = message + f'; ## POINT #{0}:\n'
        message = message + f'N0032 X{sorted_list[0][0]} Y{sorted_list[0][1]}\n'  # don't think you need it twice

        if peck:  # canned pecking cycle
            message = message + f'; ## START CANNED PECK CYCLE\n'
            message = message + f'N0034 G83 G98 R{settings_dict[machine]["ENGAGE_HEIGHT"]} Z{settings_dict[machine]["DRILL_DEPTH"]} Q{settings_dict[machine]["PECK_STEP"]} F{settings_dict[machine]["DRILL_FEED"]}\n'
        else:  # canned spot drilling cycle
            message = message + f'; ## START CANNED SPOT DRILLING CYCLE\n'
            message = message + f'N0034 G82 G98 R{settings_dict[machine]["ENGAGE_HEIGHT"]} Z{settings_dict[machine]["DRILL_DEPTH"]} P01 F{settings_dict[machine]["DRILL_FEED"]}\n'
        for ix, point in enumerate(sorted_list[1:]):
            message = message + f'X{point[0]} Y{point[1]}\n'
        message = message + f'N0036 G80 Z{settings_dict[machine]["RETRACT_HEIGHT"]}\n; ## END CANNED CYCLE\n'
        command = message + outro_code

    else:
        raise ValueError('machine must be either shapeoko or benchmill')

    # save the file  ToDo - add a directory
    if save_file:
        if time_stamp:
            outfile = f'{file_description}_{machine}_{action}_{datetime.today().strftime("%Y%m%d_%H%M%S")}.nc'
        else:
            outfile = f'{file_description}_{machine}_{action}.nc'
        with open(outfile, "w") as text_file:
            text_file.write(command)

    return command


def generate_drawing_gcode(contours, machine='shapeoko', overrides=None, peck=False, save_file=False, file_description='test'):
    # make a drawing from a list of contours (which are just points) - intended for a D&D map or other plotter application
    # set the intro and outro G code
    intro_code, outro_code = None, None

    if overrides is not None:
        # allow user to pass in a dictionary to update the machine settings
        settings_dict[machine].update(overrides)
        print(f'Using the following settings: {settings_dict[machine]}\n')

    if machine == 'shapeoko':
        intro_code = f'; ## DRY ERASE CODE AUTOGENERATED FROM POINT LIST FOR SHAPEOKO- CJH {datetime.today().strftime("%Y %m%d %H:%M:%S")}'
        intro_code += f'\nN1 G90 G20 G00 Z1. M00\n; N2 (DRY ERASE MARKER)\nG01 Z{settings_dict[machine]["RETRACT_HEIGHT"]} F{settings_dict[machine]["RETRACT_FEED"]}\n'
        outro_code = '; ## END OF POINTS\nN1520 G91 G28 Z0\nN1521 G28 X0 Y0\n; ## END OF AUTOGENERATED PROGRAM'
        # just plunges and moves - that's all the shapeoko can do
        message = intro_code
        for iy, contour in enumerate(contours):
            message = message + f'; ## CONTOUR #{iy}:\n'
            message = message + f'G01 X{contour[0][0]} Y{contour[0][1]} F{settings_dict[machine]["LINEAR_FEED"]}\n'  # initial movement to first point
            for ix, point in enumerate(contour):
                # move to x,y
                message = message + f'G01 X{point[0]} Y{point[1]} F{settings_dict[machine]["CUT_FEED"]}\n'
                if ix == 0:  # contact 
                    message = message + f'G01 Z{settings_dict[machine]["ENGAGE_HEIGHT"]} F{settings_dict[machine]["RETRACT_FEED"]}\n'
                    message = message + f'Z{settings_dict[machine]["DRILL_DEPTH"]} F{settings_dict[machine]["DRILL_FEED"]}\n'
                elif ix == len(contour)-1:  # retract
                    message = message + f"Z{settings_dict[machine]['RETRACT_HEIGHT']} F{settings_dict[machine]['RETRACT_FEED']}\n"
            command = message + outro_code
        
    else:
        raise ValueError('machine must be either shapeoko')

    # save the file  ToDo - add a directory
    if save_file:
        outfile = f'{file_description}_{machine}_line_drawing_{datetime.today().strftime("%Y%m%d_%H%M%S")}.nc'
        with open(outfile, "w") as text_file:
            text_file.write(command)

    return command


def generate_l_square(width, height, machine='shapeoko', overrides=None, save_file=False, file_description='l_test'):
    # set up an L-cut on the router (in thick lexan) so we can square up a part easily
    # we will start with the origin on the top left, and make it so the true 0,0 is where we defined it
    # i.e. we will adjust for the cutter radius so we don't have to think about it in the next machining step
    intro_code, outro_code = None, None

    if overrides is not None:
        # allow user to pass in a dictionary to update the machine settings
        settings_dict[machine].update(overrides)
    print(f'Using the following settings: {settings_dict[machine]}\n')

    if machine == 'shapeoko':
        intro_code = f'; ## L-CUT MILLING CODE AUTOGENERATED FROM POINT LIST FOR SHAPEOKO- CJH {datetime.today().strftime("%Y %m%d %H:%M:%S")}'
        intro_code += f'\nN1 G90 G20 G00 Z1. M00\n; N2 (1/4 EM CRB 3FL)\nN3 S12000 M03\nG01 Z{settings_dict[machine]["RETRACT_HEIGHT"]} F{settings_dict[machine]["RETRACT_FEED"]}\n'
        outro_code = '; ## END OF POINTS\nN1520 G91 G28 Z0\nN1521 G28 X0 Y0\n; ## END OF AUTOGENERATED PROGRAM'

        start_height = settings_dict[machine]["ENGAGE_HEIGHT"]
        end_height = - settings_dict[machine]["PART_DEPTH"]
        cut_step = - settings_dict[machine]["MILL_STEP"]
        cut_depths = np.append(np.arange(start_height, end_height, cut_step), [end_height, end_height])  # final plus a contour
        radius = settings_dict[machine]["TOOL_DIAMETER"]/2.0
        pad = settings_dict[machine]["TOOL_DIAMETER"]  # give it a bit of padding on the sides
        print(f'Cutting an L from x={width} to y={-height} in {len(cut_depths)} steps of {cut_step} from {start_height} to {end_height}')
        print(cut_depths,'\n')
        # start at the outside - far side in x
        message = intro_code +  f'\n; ## START L-CUT CYCLE\n'
        for ix, cut_depth in enumerate(cut_depths):
            message = message + f'G01 X{width+pad} Y{0-radius} F{settings_dict[machine]["LINEAR_FEED"]}\n'  # move to right, quickly
            message = message + f'G01 Z{cut_depth:.3f} F{settings_dict[machine]["DRILL_FEED"]}\n'  # lower tool
            message = message + f'G01 X{0} Y{0 - radius} F{settings_dict[machine]["CUT_FEED"]}\n'  # cut to past center
            message = message + f'G01 X{0 + radius} Y{0 - radius} F{settings_dict[machine]["CUT_FEED"]}\n'  # back to center
            message = message + f'G01 X{0 + radius} Y{0 - height - pad} F{settings_dict[machine]["CUT_FEED"]}\n'  # cut down in y
            message = message + f'Z{settings_dict[machine]["RETRACT_HEIGHT"]} F{settings_dict[machine]["RETRACT_FEED"]}\n\n'  # pull up
        command = message + outro_code
    else:
        raise ValueError('machine must be shapeoko for this feature')

    # save the file  ToDo - add a directory
    if save_file:
        outfile = f'{file_description}_{machine}_center_drill_{datetime.today().strftime("%Y%m%d_%H%M%S")}.nc'
        with open(outfile, "w") as text_file:
            text_file.write(command)

    return command


def plot_points(point_list, annotate=True, show_order=True, sort=True, connect=False):
    # plot with labels and correct aspect ratio
    sorted_list = sort_list(point_list) if sort else point_list
    #x_sort = sorted(point_list)  # sort on x values
    #y_sort = sorted(point_list, key=lambda x:x[1])  # sort on y values
    #sorted_list = x_sort if tool_travel(x_sort) < tool_travel(y_sort) else y_sort

    x = np.array([p[0] for p in sorted_list])
    y = np.array([p[1] for p in sorted_list])

    x_range = np.max(x) - np.min(x)
    y_range = np.max(y) - np.min(y)
    fig_length_min, fig_length_max = 4, 8  # try and autoscale to a reasonable size
    if x_range > y_range:
        figsize = fig_length_max, max(fig_length_min, fig_length_max * y_range / x_range)
    else:
        figsize = max(fig_length_min, fig_length_max * x_range / y_range), fig_length_max

    fig, ax = plt.subplots(figsize=figsize)

    ax.scatter(*zip(*point_list))
    
    if connect:
        ax.plot(*zip(*point_list))

    if show_order:
        for ix, point in enumerate(zip(x, y)):
            ax.annotate(f'{ix}', xy=(point[0], point[1]), xycoords='data',
                        xytext=(point[0], point[1]), textcoords='offset points', )
    if annotate:
        for ix, point in enumerate(zip(x, y)):
            ax.annotate(f'{point[0]:.1f},{point[1]:.1f}', xy=(point[0], point[1]), xycoords='data',
                        xytext=(point[0], point[1]), textcoords='offset points', )
    ax.set_xlim([min(0, np.min(x)), 0.5+ np.max(x)])
    ax.set_ylim([min(0, -0.5 +np.min(y)), max(0, 0.5+ np.max(y))])
    ax.grid(True)